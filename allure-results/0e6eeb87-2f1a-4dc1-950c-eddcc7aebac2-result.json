{"name": "test_generate_reset_token_success", "status": "failed", "statusDetails": {"message": "AssertionError: assert False", "trace": "self = <sqlalchemy.engine.base.Connection object at 0x0000026351B627D0>\ndialect = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x0000026350ADB3D0>\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x0000026352595F90>\nstatement = <sqlalchemy.dialects.postgresql.base.PGCompiler object at 0x0000026352595050>\nparameters = [{'create_datetime': datetime.datetime(2023, 12, 20, 16, 14, 6, 544824), 'token': '27Edo538GSlVoNFiFm2M6WIL5NO8ub3iGMMT3doR-lU', 'token_status': '1', 'update_datetime': datetime.datetime(2023, 12, 20, 16, 19, 6, 544824), ...}]\n\n    def _exec_single_context(\n        self,\n        dialect: Dialect,\n        context: ExecutionContext,\n        statement: Union[str, Compiled],\n        parameters: Optional[_AnyMultiExecuteParams],\n    ) -> CursorResult[Any]:\n        \"\"\"continue the _execute_context() method for a single DBAPI\n        cursor.execute() or cursor.executemany() call.\n    \n        \"\"\"\n        if dialect.bind_typing is BindTyping.SETINPUTSIZES:\n            generic_setinputsizes = context._prepare_set_input_sizes()\n    \n            if generic_setinputsizes:\n                try:\n                    dialect.do_set_input_sizes(\n                        context.cursor, generic_setinputsizes, context\n                    )\n                except BaseException as e:\n                    self._handle_dbapi_exception(\n                        e, str(statement), parameters, None, context\n                    )\n    \n        cursor, str_statement, parameters = (\n            context.cursor,\n            context.statement,\n            context.parameters,\n        )\n    \n        effective_parameters: Optional[_AnyExecuteParams]\n    \n        if not context.executemany:\n            effective_parameters = parameters[0]\n        else:\n            effective_parameters = parameters\n    \n        if self._has_events or self.engine._has_events:\n            for fn in self.dispatch.before_cursor_execute:\n                str_statement, effective_parameters = fn(\n                    self,\n                    cursor,\n                    str_statement,\n                    effective_parameters,\n                    context,\n                    context.executemany,\n                )\n    \n        if self._echo:\n            self._log_info(str_statement)\n    \n            stats = context._get_cache_stats()\n    \n            if not self.engine.hide_parameters:\n                self._log_info(\n                    \"[%s] %r\",\n                    stats,\n                    sql_util._repr_params(\n                        effective_parameters,\n                        batches=10,\n                        ismulti=context.executemany,\n                    ),\n                )\n            else:\n                self._log_info(\n                    \"[%s] [SQL parameters hidden due to hide_parameters=True]\",\n                    stats,\n                )\n    \n        evt_handled: bool = False\n        try:\n            if context.execute_style is ExecuteStyle.EXECUTEMANY:\n                effective_parameters = cast(\n                    \"_CoreMultiExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_executemany:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_executemany(\n                        cursor,\n                        str_statement,\n                        effective_parameters,\n                        context,\n                    )\n            elif not effective_parameters and context.no_parameters:\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute_no_params:\n                        if fn(cursor, str_statement, context):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n                    self.dialect.do_execute_no_params(\n                        cursor, str_statement, context\n                    )\n            else:\n                effective_parameters = cast(\n                    \"_CoreSingleExecuteParams\", effective_parameters\n                )\n                if self.dialect._has_events:\n                    for fn in self.dialect.dispatch.do_execute:\n                        if fn(\n                            cursor,\n                            str_statement,\n                            effective_parameters,\n                            context,\n                        ):\n                            evt_handled = True\n                            break\n                if not evt_handled:\n>                   self.dialect.do_execute(\n                        cursor, str_statement, effective_parameters, context\n                    )\n\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1969: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x0000026350ADB3D0>\ncursor = <cursor object at 0x000002635189CF20; closed: -1>\nstatement = 'INSERT INTO bookmazon.password_reset_tokens (user_email, token, token_status, update_datetime, create_datetime) VALUE...s, %(token)s, %(token_status)s, %(update_datetime)s, %(create_datetime)s) RETURNING bookmazon.password_reset_tokens.id'\nparameters = {'create_datetime': datetime.datetime(2023, 12, 20, 16, 14, 6, 544824), 'token': '27Edo538GSlVoNFiFm2M6WIL5NO8ub3iGMMT3doR-lU', 'token_status': '1', 'update_datetime': datetime.datetime(2023, 12, 20, 16, 19, 6, 544824), ...}\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x0000026352595F90>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       psycopg2.errors.UndefinedTable: relation \"bookmazon.password_reset_tokens\" does not exist\nE       LINE 1: INSERT INTO bookmazon.password_reset_tokens (user_email, tok...\nE                           ^\n\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:922: UndefinedTable\n\nThe above exception was the direct cause of the following exception:\n\nuser_email = '111423059@cc.ncu.edu.tw'\n\n    def generate_reset_token(user_email: str):\n        # 產生重置密碼的 token\n        reset_token = secrets.token_urlsafe(32)\n    \n        # 設定 token 的有效期（例如，5 分鐘）\n        update_datetime = datetime.now() + timedelta(minutes=5)\n    \n        # 建立一個密碼重置 token object ，並儲存到資料庫\n        token_obj = PasswordResetToken(user_email=user_email,\n                                       token=reset_token,\n                                       token_status=TokenStatus.NOT_USED.value,\n                                       update_datetime=update_datetime,\n                                       create_datetime=datetime.now())\n        # token object 儲存到資料庫\n        try:\n>           save_password_reset_token_to_database(token_obj)\n\nservice\\UserService.py:353: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\nservice\\UserService.py:383: in save_password_reset_token_to_database\n    raise e\nservice\\UserService.py:379: in save_password_reset_token_to_database\n    session.commit()\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\scoping.py:598: in commit\n    return self._proxied.commit()\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1969: in commit\n    trans.commit(_to_root=True)\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\state_changes.py:139: in _go\n    ret_value = fn(self, *arg, **kw)\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1256: in commit\n    self._prepare_impl()\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\state_changes.py:139: in _go\n    ret_value = fn(self, *arg, **kw)\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:1231: in _prepare_impl\n    self.session.flush()\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:4312: in flush\n    self._flush(objects)\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:4447: in _flush\n    with util.safe_reraise():\n..\\venv\\Lib\\site-packages\\sqlalchemy\\util\\langhelpers.py:146: in __exit__\n    raise exc_value.with_traceback(exc_tb)\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\session.py:4408: in _flush\n    flush_context.execute()\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\unitofwork.py:466: in execute\n    rec.execute(self)\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\unitofwork.py:642: in execute\n    util.preloaded.orm_persistence.save_obj(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\persistence.py:93: in save_obj\n    _emit_insert_statements(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\orm\\persistence.py:1226: in _emit_insert_statements\n    result = connection.execute(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1416: in execute\n    return meth(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\sql\\elements.py:516: in _execute_on_connection\n    return connection._execute_clauseelement(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1639: in _execute_clauseelement\n    ret = self._execute_context(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1848: in _execute_context\n    return self._exec_single_context(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1988: in _exec_single_context\n    self._handle_dbapi_exception(\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:2343: in _handle_dbapi_exception\n    raise sqlalchemy_exception.with_traceback(exc_info[2]) from e\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\base.py:1969: in _exec_single_context\n    self.dialect.do_execute(\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nself = <sqlalchemy.dialects.postgresql.psycopg2.PGDialect_psycopg2 object at 0x0000026350ADB3D0>\ncursor = <cursor object at 0x000002635189CF20; closed: -1>\nstatement = 'INSERT INTO bookmazon.password_reset_tokens (user_email, token, token_status, update_datetime, create_datetime) VALUE...s, %(token)s, %(token_status)s, %(update_datetime)s, %(create_datetime)s) RETURNING bookmazon.password_reset_tokens.id'\nparameters = {'create_datetime': datetime.datetime(2023, 12, 20, 16, 14, 6, 544824), 'token': '27Edo538GSlVoNFiFm2M6WIL5NO8ub3iGMMT3doR-lU', 'token_status': '1', 'update_datetime': datetime.datetime(2023, 12, 20, 16, 19, 6, 544824), ...}\ncontext = <sqlalchemy.dialects.postgresql.psycopg2.PGExecutionContext_psycopg2 object at 0x0000026352595F90>\n\n    def do_execute(self, cursor, statement, parameters, context=None):\n>       cursor.execute(statement, parameters)\nE       sqlalchemy.exc.ProgrammingError: (psycopg2.errors.UndefinedTable) relation \"bookmazon.password_reset_tokens\" does not exist\nE       LINE 1: INSERT INTO bookmazon.password_reset_tokens (user_email, tok...\nE                           ^\nE       \nE       [SQL: INSERT INTO bookmazon.password_reset_tokens (user_email, token, token_status, update_datetime, create_datetime) VALUES (%(user_email)s, %(token)s, %(token_status)s, %(update_datetime)s, %(create_datetime)s) RETURNING bookmazon.password_reset_tokens.id]\nE       [parameters: {'user_email': '111423059@cc.ncu.edu.tw', 'token': '27Edo538GSlVoNFiFm2M6WIL5NO8ub3iGMMT3doR-lU', 'token_status': '1', 'update_datetime': datetime.datetime(2023, 12, 20, 16, 19, 6, 544824), 'create_datetime': datetime.datetime(2023, 12, 20, 16, 14, 6, 544824)}]\nE       (Background on this error at: https://sqlalche.me/e/20/f405)\n\n..\\venv\\Lib\\site-packages\\sqlalchemy\\engine\\default.py:922: ProgrammingError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_user_service.TestUserService object at 0x000002635187B8D0>\n\n    @pytest.mark.generate_reset_token_success\n    def test_generate_reset_token_success(self):\n        try:\n>           generate_reset_token(\"111423059@cc.ncu.edu.tw\")\n\ntest\\test_user_service.py:172: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _\n\nuser_email = '111423059@cc.ncu.edu.tw'\n\n    def generate_reset_token(user_email: str):\n        # 產生重置密碼的 token\n        reset_token = secrets.token_urlsafe(32)\n    \n        # 設定 token 的有效期（例如，5 分鐘）\n        update_datetime = datetime.now() + timedelta(minutes=5)\n    \n        # 建立一個密碼重置 token object ，並儲存到資料庫\n        token_obj = PasswordResetToken(user_email=user_email,\n                                       token=reset_token,\n                                       token_status=TokenStatus.NOT_USED.value,\n                                       update_datetime=update_datetime,\n                                       create_datetime=datetime.now())\n        # token object 儲存到資料庫\n        try:\n            save_password_reset_token_to_database(token_obj)\n            return reset_token\n        except Exception as e:\n            app_logger.error('Error generating reset token: %s', e)\n            message = CommonSystemCode.DATABASE_FAILED.value.get('message')\n            system_code = CommonSystemCode.DATABASE_FAILED.value.get('system_code')\n>           raise BusinessError(error_code=system_code, message=message)\nE           exception.BusinessError.BusinessError: 目前資料庫異常，請稍候嘗試，或聯繫網站管理人員\n\nservice\\UserService.py:359: BusinessError\n\nDuring handling of the above exception, another exception occurred:\n\nself = <test_user_service.TestUserService object at 0x000002635187B8D0>\n\n    @pytest.mark.generate_reset_token_success\n    def test_generate_reset_token_success(self):\n        try:\n            generate_reset_token(\"111423059@cc.ncu.edu.tw\")\n            assert True\n        except BusinessError:\n>           assert False\nE           assert False\n\ntest\\test_user_service.py:175: AssertionError"}, "attachments": [{"name": "log", "source": "f18b902f-b81d-4aff-9db1-791137f34aaf-attachment.txt", "type": "text/plain"}, {"name": "stdout", "source": "2c6b258f-f1c4-4053-96d9-d0ac405c423b-attachment.txt", "type": "text/plain"}, {"name": "stderr", "source": "a86d848b-d669-4877-af3b-a7d8700b009f-attachment.txt", "type": "text/plain"}], "start": 1703060046545, "stop": 1703060046548, "uuid": "d7b8e989-1ad3-43c6-b520-52ce44476293", "historyId": "61ede121f44746c3d7ced8fc629dd2d3", "testCaseId": "61ede121f44746c3d7ced8fc629dd2d3", "fullName": "test.test_user_service.TestUserService#test_generate_reset_token_success", "labels": [{"name": "tag", "value": "generate_reset_token_success"}, {"name": "parentSuite", "value": "test"}, {"name": "suite", "value": "test_user_service"}, {"name": "subSuite", "value": "TestUserService"}, {"name": "host", "value": "LAPTOP-SJL5AU2K"}, {"name": "thread", "value": "59520-MainThread"}, {"name": "framework", "value": "pytest"}, {"name": "language", "value": "cpython3"}, {"name": "package", "value": "test.test_user_service"}]}